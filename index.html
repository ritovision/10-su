---
layout: null
image: "{{ site.baseurl }}/assets/images/su-OG.png"
title: Billboard homepage
---
<!doctype html>
<html lang="en">

<head>
  <script>window.SITE_BASEURL = "{{ site.baseurl }}";</script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  {% include pwa-meta-tags.html %}
  {% seo %}
  <meta name="description" content="The first ERC-721 NFT. Cute squares you own and personalize for the homepage.">
  <link rel="canonical" href="https://tenthousandsu.com" />
  <link rel="stylesheet" href="{{ site.baseurl }}/assets/css/main.css">
  <link rel="stylesheet" href="{{ site.baseurl }}/assets/css/index.css">
  <link rel="stylesheet" href="{{ site.baseurl }}/assets/square-lookup/styles.css">
  {% include nav-menu-head.html %}
  {% include alert-modal-head.html %}
  {% include offline-modal-head.html %}
  <link rel="stylesheet" href="{{ site.baseurl }}/assets/modals/leaving-modal/modal.css">
  <script src="{{ site.baseurl }}/assets/modals/leaving-modal/modal-core.js"></script>
  <script src="{{ site.baseurl }}/assets/modals/leaving-modal/link-guard.js"></script>
</head>

<body>
  {% include nav-header.html %}

  <article>
    <h1 class="home-title">The first <span class="no-break">ERC-721</span> NFT</h1>
    <p>Click an empty square below to mint an available Su Square (<span id="mint-price-display">0.5 ETH</span>).
      Clicking an already minted and personalized
      one will activate its hyperlink.</p>
    <p class="mobile-hint">Pinch to zoom, drag to pan</p>
    <script>
      // Only update if there's a pricing override to avoid performance tax
      // Uses DOMContentLoaded because runtime.generated.js is deferred
      document.addEventListener("DOMContentLoaded", function () {
        var cfg = window.suWeb3 || window.SU_WEB3 || {};
        var pricing = cfg.pricing;
        if (pricing && typeof pricing.mintPriceEth === "number" && pricing.mintPriceEth !== 0.5) {
          var el = document.getElementById("mint-price-display");
          if (el) el.textContent = pricing.mintPriceEth + " ETH";
        }
      });
    </script>
    <a id="wheretogo" class="map-container" href="#" target="_blank">
      <div class="map-wrapper">
        <img id="theImage" class="map-image"
          src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" alt="All Su Squares">
        <div id="position" class="map-position"></div>
        <div id="tooltip" class="map-tooltip"></div>
        <div id="electric-fence" class="map-fence"></div>
      </div>
    </a>
    <button id="map-reset-btn" class="map-reset-btn" type="button">Reset zoom</button>
  </article>

  <article class="newly-feed">
    <section id="newly-minted" class="newly-feed__section">
      <strong class="newly-feed__heading">Newly minted</strong>
      <div class="newly-feed__items"></div>
    </section>
    <section id="newly-personalized" class="newly-feed__section">
      <strong class="newly-feed__heading">Latest personalized</strong>
      <div class="newly-feed__items"></div>
    </section>
  </article>

  {% include square-lookup.html %}

  <section class="developer-learning" aria-labelledby="developer-learning-title">
    <div class="developer-learning__inner">
      <h2 id="developer-learning-title" class="developer-learning__title">Developer Learning</h2>
      <p class="developer-learning__subtitle">Learn the technicals behind how this historic project works.</p>

      <p class="developer-learning__intro">
        Su Squares is much more than a historic collectible billboard on Ethereum... it’s a complete, open-source project you can study,
        run, and modify yourself. The same GitHub repository that powers this live Jekyll site also contains the smart
        contracts, local blockchain setup, UI library, and tests that make the project work end-to-end.
      </p>

      <p class="developer-learning__lead">Inside the repo you can:</p>

      <div class="developer-learning__grid">
        <section class="developer-learning__item">
          <h3 class="developer-learning__item-title">Run the full site locally</h3>
          <p class="developer-learning__item-body">
            Spin up your own Su Squares site offline, including a private local Ethereum-like network configured for you.
            You can experiment safely without touching mainnet or spending real ETH.
          </p>
        </section>

        <section class="developer-learning__item">
          <h3 class="developer-learning__item-title">Explore the smart contracts in depth</h3>
          <p class="developer-learning__item-body">
            Inspect the two contracts that power Su Squares on Ethereum and call them using accessible scripts and npm
            tasks—no need to write raw <code>eth_call</code> or RPC by hand.
          </p>
        </section>

        <section class="developer-learning__item">
          <h3 class="developer-learning__item-title">See the full UI in Storybook</h3>
          <p class="developer-learning__item-body">
            Browse the production UI components in isolation: the billboard, square lookup tools, choosers, wallet and
            transaction modals, offline banner, nav, and more. It’s the live interface broken down into testable, reusable
            pieces.
          </p>
        </section>

        <section class="developer-learning__item">
          <h3 class="developer-learning__item-title">Run automated tests like a real dapp team</h3>
          <p class="developer-learning__item-body">
            Use Playwright to run end-to-end browser tests against the app, and Vitest to validate helper logic and
            behavior. You can watch how a production NFT project wires testing around contracts and UI.
          </p>
        </section>

        <section class="developer-learning__item developer-learning__item--full">
          <h3 class="developer-learning__item-title">Understand the build and tooling stack</h3>
          <p class="developer-learning__item-body">
            Examine the Node.js workspaces that handle contracts, local network scripts, UI tooling, and test runners,
            alongside the Jekyll code that renders this very site. Everything is wired so you can clone, install
            dependencies, and follow the same commands we use.
          </p>
        </section>
      </div>

      <a
        class="developer-learning__cta"
        href="https://github.com/su-squares/tenthousandsu.com"
        target="_blank"
        rel="noreferrer"
      >
        <span class="developer-learning__cta-text">View on GitHub</span>
        <span class="developer-learning__cta-icon" aria-hidden="true">
          <img src="{{ site.baseurl }}/assets/images/github-logo.svg" alt="GitHub" />
        </span>
      </a>
    </div>
  </section>

  <footer>
    <small>
      No cookies. No analytics. Not responsible for content of linked sites. Images shown on homepage are &copy; their
      respective owners. This image refreshes <a target="_blank"
        href="https://github.com/su-squares/tenthousandsu.com/actions/workflows/load-from-blockchain.yml">hourly</a>. To
      the extent possible under law, Su Entriken has waived
      all copyright and related or neighboring rights to the TenThousandSu.com website. This work is published from the
      United States.
    </small>
  </footer>
  <script type="module">
    import { createPanZoom } from "{{ site.baseurl }}/assets/js/pan-zoom.js";

    document.addEventListener("DOMContentLoaded", () => {
      try {
        const baseurl = window.SITE_BASEURL || '';
        const runtimeCfg = window.suWeb3 || window.SU_WEB3 || {};
        const runtimeChain =
          (runtimeCfg.chain || runtimeCfg.CHAIN || runtimeCfg.network || runtimeCfg.NETWORK || "mainnet").toString().toLowerCase();
        const runtimeAssetBases = runtimeCfg.assetBases || {};
        let assetBase = String(runtimeAssetBases[runtimeChain] || "/build").replace(/\/+$/, "");
        if (baseurl && !assetBase.startsWith(baseurl)) {
          assetBase = baseurl + assetBase;
        }
        const assetPath = (rel) => `${assetBase}/${String(rel).replace(/^\/+/, "")}`;

        const normalizeHref = window.suNormalizeHref || ((href) => href); // fallback if helper not loaded

        let positionSquareNumber = 1;
        let hasActiveSelection = false;
        var squarePersonalizations = [];
        var squareExtra = [];

        // Animate the electric fence
        let fence = new Set();
        let litUpEdge = new Set();
        let wasEverLitUp = new Set();
        const whereToGoAnchor = document.getElementById("wheretogo");
        if (whereToGoAnchor) {
          whereToGoAnchor.removeAttribute("href");
        }

        // Initialize pan-zoom on the map wrapper (mobile only)
        const mapWrapper = document.querySelector(".map-wrapper");
        const panZoom = mapWrapper ? createPanZoom(mapWrapper) : null;

        // Wire up reset button
        const resetBtn = document.getElementById("map-reset-btn");
        if (resetBtn && panZoom) {
          resetBtn.addEventListener("click", () => {
            panZoom.reset();
          });
        }

        const squarePersonalizationsPromise = fetch(assetPath("squarePersonalizations.json")).then(response => response.json());
        const squareExtraPromise = fetch(assetPath("squareExtra.json")).then(response => response.json());

        const theImage = document.getElementById("theImage");
        if (theImage) {
          theImage.src = assetPath("wholeSquare.png");
        }

        Promise.all([squarePersonalizationsPromise, squareExtraPromise])
          .then(([personalizations, extra]) => {
            squarePersonalizations = personalizations; /* [title, href] or null */
            squareExtra = extra; /* [mintedBlock, updatedBlock, mainIsPersonalized, version */

            // Start fence animation
            lightUpFence(new Set([1]));

            // Show newly minted and personalized Squares
            const newlyMintedSection = document.getElementById("newly-minted");
            const newlyPersonalizedSection = document.getElementById("newly-personalized");
            const newlyMintedList = newlyMintedSection.querySelector(".newly-feed__items");
            const newlyPersonalizedList = newlyPersonalizedSection.querySelector(".newly-feed__items");
            const mostRecentMintedSquares = squareExtra
              .map((extraData, index) => [index, extraData])
              .filter(([index, extraData]) => extraData !== null)
              .sort((a, b) => b[1][0 /* mintedBlock */] - a[1][0])
              .slice(0, 5);
            mostRecentMintedSquares.forEach(([index, extraData]) => {
              const row = Math.floor((index) / 100);
              const col = (index) % 100;
              const squareNumber = index + 1;
              const thumbUrl = assetPath("wholeSquare.png");
              newlyMintedList.insertAdjacentHTML(
                "beforeend",
                `<a class="newly-feed__item" href="${baseurl}/square#${squareNumber}">
                  <span class="newly-feed__thumb" style="background-image:url('${thumbUrl}'); background-position:${-col * 10}px ${-row * 10}px;"></span>
                  <p>#${squareNumber}</p>
                </a>`
              );
            });
            const mostRecentPersonalizedSquares = squareExtra
              .map((extraData, index) => [index, extraData])
              .filter(([index, extraData]) => extraData !== null)
              .filter(([index, extraData]) => extraData[1] !== extraData[0])
              .sort((a, b) => b[1][1 /* updatedBlock */] - a[1][1])
              .slice(0, 5);
            mostRecentPersonalizedSquares.forEach(([index, extraData]) => {
              const row = Math.floor((index) / 100);
              const col = (index) % 100;
              const squareNumber = index + 1;
              const thumbUrl = assetPath("wholeSquare.png");
              newlyPersonalizedList.insertAdjacentHTML(
                "beforeend",
                `<a class="newly-feed__item" href="${baseurl}/square#${squareNumber}">
                  <span class="newly-feed__thumb" style="background-image:url('${thumbUrl}'); background-position:${-col * 10}px ${-row * 10}px;"></span>
                  <p>#${squareNumber}</p>
                </a>`
              );
            });
          })
          .catch((error) => {
            console.error("Failed to load square data", error);
          });

        const GRID_DIMENSION = 100;

        function getCellSize() {
          // Use original (pre-transform) dimensions when pan-zoom is active
          if (mapWrapper && panZoom && panZoom.isActive) {
            return mapWrapper.offsetWidth / GRID_DIMENSION;
          }
          const rect = document.getElementById("theImage").getBoundingClientRect();
          return rect.width ? rect.width / GRID_DIMENSION : 10;
        }

        function setPosition(squareNumber) {
          positionSquareNumber = squareNumber;
          const positionDiv = document.getElementById("position");
          const tooltipDiv = document.getElementById("tooltip");
          hasActiveSelection = true;
          if (!whereToGoAnchor) {
            return;
          }
          const cellSize = getCellSize();
          const col = (squareNumber - 1) % GRID_DIMENSION;
          const row = Math.floor((squareNumber - 1) / GRID_DIMENSION);

          const normalizedHref = normalizeHref(squarePersonalizations[squareNumber - 1]?.[1]);

          if (!squarePersonalizations[squareNumber - 1]) {
            document.getElementById("theImage").style.cursor = "pointer";
            tooltipDiv.textContent = "Square #" + squareNumber + " is available for sale, click to buy.";
            whereToGoAnchor.href = baseurl + "/buy?square=" + squareNumber;
          } else if (!squarePersonalizations[squareNumber - 1][0] && !squarePersonalizations[squareNumber - 1][1]) {
            document.getElementById("theImage").style.cursor = "not-allowed";
            tooltipDiv.textContent = "Square #" + squareNumber + " WAS PURCHASED BUT NOT YET PERSONALIZED";
            whereToGoAnchor.removeAttribute("href");
          } else {
            document.getElementById("theImage").style.cursor = "pointer";
            tooltipDiv.textContent = "Square #" + squareNumber + " " + squarePersonalizations[squareNumber - 1][0];
            if (normalizedHref) {
              whereToGoAnchor.href = normalizedHref;
            } else {
              whereToGoAnchor.removeAttribute("href");
            }
          }

          positionDiv.style.width = cellSize + "px";
          positionDiv.style.height = cellSize + "px";
          positionDiv.style.left = (col * cellSize) + "px";
          positionDiv.style.top = (row * cellSize) + "px";
          positionDiv.style.display = "block";

          // Position tooltip based on which half of the grid the square is in
          // Left half (columns 0-49): tooltip appears to the right
          // Right half (columns 50-99): tooltip appears to the left
          const isLeftHalf = col < GRID_DIMENSION / 2;
          if (isLeftHalf) {
            tooltipDiv.style.left = (col * cellSize + cellSize * 1.5) + "px";
            tooltipDiv.style.right = "auto";
          } else {
            tooltipDiv.style.left = "auto";
            tooltipDiv.style.right = ((GRID_DIMENSION - col - 1) * cellSize + cellSize * 1.5) + "px";
          }

          // Vertical positioning based on row to prevent edge overflow
          // Top 5000 squares (rows 0-49): tooltip appears below the square
          // Bottom 5000 squares (rows 50-99): tooltip appears above the square
          const isTopHalf = row < GRID_DIMENSION / 2;
          if (isTopHalf) {
            tooltipDiv.style.top = ((row + 1) * cellSize) + "px";
            tooltipDiv.style.transformOrigin = `${isLeftHalf ? "left" : "right"} top`;
          } else {
            tooltipDiv.style.top = (row * cellSize) + "px";
            tooltipDiv.style.transformOrigin = `${isLeftHalf ? "left" : "right"} bottom`;
          }

          // Scale tooltip with pan-zoom (mobile only)
          const yTransform = isTopHalf ? "" : "translateY(-100%)";
          if (panZoom && panZoom.isActive && panZoom.scale) {
            tooltipDiv.style.transform = `${yTransform} scale(${1 / panZoom.scale})`;
          } else {
            tooltipDiv.style.transform = yTransform;
          }

          tooltipDiv.style.display = "block";
        }

        window.addEventListener("resize", () => {
          if (document.getElementById("tooltip").style.display === "block") {
            setPosition(positionSquareNumber);
          }
        });

        function clearSelection() {
          const positionDiv = document.getElementById("position");
          const tooltipDiv = document.getElementById("tooltip");
          positionDiv.style.display = "none";
          tooltipDiv.style.display = "none";
          hasActiveSelection = false;
          if (whereToGoAnchor) {
            whereToGoAnchor.removeAttribute("href");
          }
        }

        function getSquareFromPointer(clientX, clientY) {
          const cellSize = getCellSize();
          let x, y;

          if (panZoom && panZoom.isActive) {
            // Convert screen coords to canvas coords
            const coords = panZoom.screenToCanvas(clientX, clientY);
            x = Math.min(Math.max(Math.floor(coords.x / cellSize), 0), GRID_DIMENSION - 1);
            y = Math.min(Math.max(Math.floor(coords.y / cellSize), 0), GRID_DIMENSION - 1);
          } else {
            const theImage = document.getElementById("theImage");
            const rect = theImage.getBoundingClientRect();
            x = Math.min(Math.max(Math.floor((clientX - rect.left) / cellSize), 0), GRID_DIMENSION - 1);
            y = Math.min(Math.max(Math.floor((clientY - rect.top) / cellSize), 0), GRID_DIMENSION - 1);
          }

          return x + y * GRID_DIMENSION + 1;
        }

        document.getElementById("theImage").addEventListener("mousemove", (e) => {
          const squareNumber = getSquareFromPointer(e.clientX, e.clientY);
          setPosition(squareNumber);
        });
        document.getElementById("theImage").addEventListener("mouseleave", clearSelection);

        // Touch support for pan-zoom
        document.getElementById("theImage").addEventListener("touchend", (e) => {
          // Suppress selection if user was panning/zooming
          if (panZoom && panZoom.hasPanned && panZoom.hasPanned()) {
            return;
          }
          if (e.changedTouches && e.changedTouches[0]) {
            const touch = e.changedTouches[0];
            const squareNumber = getSquareFromPointer(touch.clientX, touch.clientY);
            setPosition(squareNumber);
          }
        });

        document.addEventListener("keydown", (e) => {
          const key = e.key.toLowerCase();
          if (key === "w" || key === "," || key === "arrowup") {
            if (positionSquareNumber > GRID_DIMENSION) setPosition(positionSquareNumber - GRID_DIMENSION);
            e.preventDefault();
          } else if (key === "a" || key === "arrowleft") {
            if (positionSquareNumber % GRID_DIMENSION !== 1) setPosition(positionSquareNumber - 1);
          } else if (key === "s" || key === "o" || key === "arrowdown") {
            if (positionSquareNumber <= GRID_DIMENSION * (GRID_DIMENSION - 1)) setPosition(positionSquareNumber + GRID_DIMENSION);
            e.preventDefault();
          } else if (key === "d" || key === "e" || key === "arrowright") {
            if (positionSquareNumber % GRID_DIMENSION !== 0) setPosition(positionSquareNumber + 1);
          } else if (key === "enter") {
            if (hasActiveSelection && whereToGoAnchor && whereToGoAnchor.hasAttribute("href")) {
              whereToGoAnchor.click();
            }
          }
        });

        function handleWhereToGoClick(event) {
          // Suppress click if user was panning/zooming
          if (panZoom && panZoom.hasPanned && panZoom.hasPanned()) {
            event.preventDefault();
            return;
          }

          if (!whereToGoAnchor) {
            return;
          }

          const href = whereToGoAnchor.getAttribute("href");
          if (!href || href === "#") {
            return;
          }

          const modal = window.SuLeavingModal;
          if (!modal || typeof modal.shouldWarnForUrl !== "function" || typeof modal.show !== "function") {
            return;
          }

          let destination;
          try {
            destination = new URL(href, window.location.href);
          } catch (error) {
            return;
          }

          if (!modal.shouldWarnForUrl(destination)) {
            return;
          }

          event.preventDefault();
          modal.show(destination, whereToGoAnchor.getAttribute("target") || "_self");
        }

        if (whereToGoAnchor) {
          whereToGoAnchor.addEventListener("click", handleWhereToGoClick);
        }

        function lightUpFence(edge) {
          litUpEdge.forEach(s => {
            const element = document.getElementById("electric-fence-" + s);
            if (element && element.parentNode) {
              element.parentNode.removeChild(element);
            }
          });
          litUpEdge.clear();
          let nextEdge = new Set();
          edge.forEach((square) => {
            wasEverLitUp.add(square);
            const element = document.createElement("div");
            element.id = "electric-fence-" + square;
            element.style.pointerEvents = "none";
            element.style.position = "absolute";
            element.style.left = ((square - 1) % GRID_DIMENSION) + "%";
            element.style.top = Math.floor((square - 1) / GRID_DIMENSION) + "%";
            element.style.width = "1%";
            element.style.height = "1%";
            element.style.background = "#ffd700";
            element.style.opacity = "0.25";
            document.getElementById("electric-fence").appendChild(element);
            if (squarePersonalizations[square - 1] !== null) {
              litUpEdge.add(square);
              if (square > GRID_DIMENSION && !wasEverLitUp.has(square - GRID_DIMENSION)) {
                nextEdge.add(square - GRID_DIMENSION);
              }
              if (square <= GRID_DIMENSION * (GRID_DIMENSION - 1) && !wasEverLitUp.has(square + GRID_DIMENSION)) {
                nextEdge.add(square + GRID_DIMENSION);
              }
              if (square % GRID_DIMENSION != 1 && !wasEverLitUp.has(square - 1)) {
                nextEdge.add(square - 1);
              }
              if (square % GRID_DIMENSION != 0 && !wasEverLitUp.has(square + 1)) {
                nextEdge.add(square + 1);
              }
            } else {
              fence.add(square);
            }
          });
          if (nextEdge.size > 0) {
            setTimeout(() => {
              lightUpFence(nextEdge);
            }, 25);
          }
        }
      } catch (error) {
        console.error("Homepage init failed", error);
      }
    });
  </script>
  <script type="module" src="{{ site.baseurl }}/assets/square-lookup/index.js"></script>
  <script src="{{ site.baseurl }}/assets/js/pwa-init.js"></script>
</body>

</html>
